# ğŸ§  AnÃ¡lisis de Algoritmos

El anÃ¡lisis de algoritmos es una rama fundamental de la teorÃ­a de la complejidad computacional. Su objetivo es estimar teÃ³ricamente los recursos necesarios (tiempo y espacio) que un algoritmo requiere para resolver un problema especÃ­fico. Dado que la mayorÃ­a de los algoritmos estÃ¡n diseÃ±ados para manejar entradas de longitud arbitraria, es esencial determinar cÃ³mo escalan en eficiencia.

- **Complejidad de tiempo**: Relaciona la longitud de la entrada con el nÃºmero de pasos necesarios para ejecutar el algoritmo.
- **Complejidad de espacio**: Relaciona la longitud de la entrada con la cantidad de memoria requerida durante la ejecuciÃ³n.

---

# ğŸ”§ Algoritmo

Un algoritmo es una secuencia clara y ordenada de pasos que, al seguirse, permite resolver un problema o realizar una tarea especÃ­fica. Son esenciales en programaciÃ³n y se aplican en diversas Ã¡reas, desde la cocina hasta la inteligencia artificial.

En informÃ¡tica, un algoritmo es un conjunto de instrucciones definidas, ordenadas y finitas que permiten resolver un problema, realizar un cÃ¡lculo o llevar a cabo una tarea. Es decir, es un procedimiento paso a paso para alcanzar un objetivo. A partir de un estado e informaciÃ³n iniciales, se siguen pasos ordenados hasta llegar a la soluciÃ³n.

> ğŸ’¡ **Nota**: En programaciÃ³n, diseÃ±ar un algoritmo es el paso previo a escribir el cÃ³digo.

## ğŸ“ Ejemplos

- **Recetas de cocina**: Explican paso a paso cÃ³mo preparar un platillo.
- **Instrucciones de ensamblaje**: Como las de armar un set de LEGO, detallan cada paso para construir una figura.
- **Manuales de usuario**: GuÃ­an al usuario en la configuraciÃ³n o uso de dispositivos.

---

# ğŸ§® Algoritmia

La algoritmia es la ciencia que estudia los algoritmos, es decir, conjuntos de instrucciones que permiten resolver problemas o realizar tareas. Se enfoca en el diseÃ±o, anÃ¡lisis y eficiencia de los algoritmos, buscando la mejor manera de solucionar problemas de forma automÃ¡tica.

## ğŸ¯ Objetivos

- DiseÃ±ar algoritmos eficientes que resuelvan problemas de forma Ã³ptima, utilizando la menor cantidad de recursos (tiempo y memoria).
- Analizar la eficiencia de los algoritmos, determinando su tiempo de ejecuciÃ³n y espacio de memoria requerido.
- Desarrollar herramientas y tÃ©cnicas para la creaciÃ³n de algoritmos, como pseudocÃ³digo o diagramas de flujo.

## ğŸ§ª Casos de Entrada

- **Mejor caso**: SituaciÃ³n mÃ¡s favorable para el algoritmo, donde el tiempo de ejecuciÃ³n o el espacio requerido son mÃ­nimos.
- **Caso promedio**: Tiempo de ejecuciÃ³n o espacio requerido para una entrada aleatoria tÃ­pica.
- **Peor caso**: SituaciÃ³n mÃ¡s desfavorable para el algoritmo, donde el tiempo de ejecuciÃ³n o el espacio requerido son mÃ¡ximos.

## ğŸ§° Tipos de AnÃ¡lisis

- **Cuantitativos y cualitativos**: Basados en cÃ¡lculos matemÃ¡ticos o secuencias lÃ³gicas.
- **Computacionales o no computacionales**: Dependiendo de si requieren o no el uso de un ordenador.
- **Algoritmos de bÃºsqueda**: Encuentran elementos con ciertas propiedades dentro de una estructura de datos.
- **Algoritmos de ordenamiento**: Reorganizan elementos de una lista siguiendo un orden numÃ©rico o alfanumÃ©rico.
- **Algoritmos voraces**: Aplicados a problemas de optimizaciÃ³n, toman decisiones lÃ³gicas para llegar a una soluciÃ³n global. No son reversibles una vez ejecutados.
- **ProgramaciÃ³n dinÃ¡mica**: La soluciÃ³n de un problema depende de soluciones a subproblemas mÃ¡s pequeÃ±os.
- **Algoritmos probabilÃ­sticos**: Basan sus resultados en el azar, buscando obtener buenas soluciones para cualquier distribuciÃ³n aleatoria de entradas.

---

# ğŸ§© Complejidad Computacional

La complejidad computacional es una Ã¡rea clave en informÃ¡tica que estudia los recursos necesarios para resolver problemas computacionales, enfocÃ¡ndose en:

- **Tiempo**: Cantidad de pasos necesarios para llegar a una soluciÃ³n.
- **Espacio**: Cantidad de memoria que un algoritmo necesita durante su ejecuciÃ³n.

---

# ğŸ“… SEMANA 1

## ğŸ§  Algoritmia Elemental

Introduce conceptos bÃ¡sicos como eficiencia, anÃ¡lisis de casos y algoritmos simples (bÃºsqueda lineal, binaria, ordenamientos). TambiÃ©n incluye la comprensiÃ³n de operaciones bÃ¡sicas y estructuras de control, como bucles y sentencias condicionales.

### ğŸ”¤ NotaciÃ³n

- **PseudocÃ³digo**: RepresentaciÃ³n textual de un algoritmo.
- **Diagramas de flujo**: RepresentaciÃ³n visual de los pasos de un algoritmo.

### ğŸ“ IntroducciÃ³n MatemÃ¡tica

La matemÃ¡tica en algoritmia elemental se basa en operaciones bÃ¡sicas para resolver problemas de manera estructurada y lÃ³gica. Un algoritmo es una serie de instrucciones claras y ordenadas que permiten resolver un problema especÃ­fico.

### âš ï¸ ContradicciÃ³n

Una contradicciÃ³n ocurre cuando las declaraciones lÃ³gicas dentro de un algoritmo son incompatibles o producen resultados opuestos.

---

# ğŸ“… SEMANA 2

## âš™ï¸ Eficiencia de los Algoritmos

La eficiencia de un algoritmo se refiere a su capacidad para resolver problemas de manera Ã³ptima en tÃ©rminos de tiempo y espacio de memoria.

Medir la eficiencia ayuda a predecir el comportamiento del algoritmo y a compararlo con otros, mejorando la resoluciÃ³n de problemas y la gestiÃ³n de datos.

## ğŸ“Š Caso Medio

Representa el rendimiento promedio de un algoritmo considerando todas las entradas posibles y sus probabilidades.

### ğŸ§ª Ejemplo:

En una bÃºsqueda lineal en una lista:

- **Mejor caso**: El elemento buscado es el primero â†’ 1 comparaciÃ³n.
- **Peor caso**: El elemento es el Ãºltimo o no estÃ¡ â†’ n comparaciones.
- **Caso medio**: Aproximadamente n/2 comparaciones.

---

# ğŸ“… SEMANA 3

## ğŸš¨ Peor Caso

El peor caso representa el escenario mÃ¡s desfavorable en la ejecuciÃ³n de un algoritmo. Este anÃ¡lisis determina el mÃ¡ximo de recursos (tiempo o memoria) que puede consumir un algoritmo.

### ğŸ§­ Importancia

- **GarantÃ­a de rendimiento**: Saber cuÃ¡nto puede tardar como mÃ¡ximo.
- **Toma de decisiones**: Ãštil en sistemas donde el tiempo de respuesta es crÃ­tico.
- **OptimizaciÃ³n**: Permite mejorar algoritmos al conocer sus lÃ­mites.

### ğŸ§ª Ejemplo:

En una **bÃºsqueda secuencial**:

- **Peor caso**: El elemento no estÃ¡ en la lista â†’ se recorren los `n` elementos.

En **ordenamiento por selecciÃ³n (selection sort)**:

- Siempre realiza la misma cantidad de comparaciones, sin importar el orden â†’ el peor caso es igual al caso promedio.

### ğŸ“Œ NotaciÃ³n Big-O (O-grande)

La notaciÃ³n Big-O se utiliza para describir el comportamiento del algoritmo en el peor de los casos. Ejemplos:

- BÃºsqueda lineal: O(n)
- BÃºsqueda binaria: O(log n)
- Ordenamiento burbuja: O(nÂ²)
- Ordenamiento rÃ¡pido (QuickSort): O(nÂ²) en el peor caso, pero en promedio O(n log n)

---
# ğŸ“š Semana 4: NotaciÃ³n para el Orden (Big O)

## ğŸ” Â¿QuÃ© es la notaciÃ³n Big O?

Es una notaciÃ³n asintÃ³tica que describe la eficiencia de un algoritmo en funciÃ³n del tamaÃ±o de la entrada **n**.

Se centra en el crecimiento del tiempo o espacio requerido cuando la entrada aumenta.

Representa la cota superior del rendimiento del algoritmo (peor caso).

## ğŸ“Œ Ejemplos comunes

| NotaciÃ³n   | Nombre        | DescripciÃ³n breve                                      |
|------------|---------------|-------------------------------------------------------|
| O(1)       | Constante     | No depende del tamaÃ±o de la entrada.                  |
| O(n)       | Lineal        | Crece proporcionalmente a **n**.                      |
| O(log n)   | LogarÃ­tmica   | Crece lentamente, incluso si **n** aumenta mucho.     |
| O(n log n) | Quasilineal   | MÃ¡s rÃ¡pido que cuadrÃ¡tico, comÃºn en algoritmos de ordenamiento. |
| O(nÂ²)      | CuadrÃ¡tica    | Tiempo crece con el cuadrado del tamaÃ±o de entrada.    |
| O(2â¿)      | Exponencial   | Muy ineficiente; crece rÃ¡pidamente.                    |
| O(n!)      | Factorial     | Extremadamente ineficiente, tÃ­pico en algoritmos de fuerza bruta. |

## ğŸ§  Elementos clave

- Se expresa como **O(g(n))**, donde *g(n)* es una funciÃ³n que representa el crecimiento del algoritmo.
- Proporciona una cota superior, asegurando que no se necesitarÃ¡n mÃ¡s recursos que *g(n)* para entradas grandes.

---

# ğŸ“š Semana 5: Notaciones Î© (Omega) y Î˜ (Theta)

## ğŸ” Â¿QuÃ© es la notaciÃ³n Î© (Omega)?

Describe la **cota inferior** de un algoritmo, es decir, el mejor caso posible.

Asegura que el algoritmo tomarÃ¡ al menos esa cantidad de recursos para entradas grandes.

### ğŸ§  Ejemplo:

Si un algoritmo tiene **Î©(n)**, en el mejor de los casos requiere al menos **n** pasos para completarse.

## ğŸ” Â¿QuÃ© es la notaciÃ³n Î˜ (Theta)?

Describe un lÃ­mite ajustado (superior e inferior).

El algoritmo siempre tarda un tiempo proporcional a **g(n)** (ni mÃ¡s, ni menos asintÃ³ticamente).

### ğŸ¯ InterpretaciÃ³n

- **Cota estricta:** El tiempo de ejecuciÃ³n estÃ¡ acotado por arriba y por abajo.
- **Rendimiento promedio:** Representa bien el caso medio o comportamiento tÃ­pico.

### Ejemplo:

Un algoritmo con **Î˜(n log n)** se comporta asÃ­ en la mayorÃ­a de los casos, no solo en el peor o mejor.

---

## ğŸ“Œ NotaciÃ³n asintÃ³tica condicional

### ğŸ”§ Â¿QuÃ© es?

MÃ©todo para describir cÃ³mo un algoritmo escala con el tamaÃ±o de la entrada.

Se aplica a tiempo y espacio.

### ğŸ§  Â¿Para quÃ© sirve?

- Comparar algoritmos: Determinar cuÃ¡l es mÃ¡s eficiente.
- Simplificar anÃ¡lisis: Ignorar detalles menores y centrarse en el crecimiento.
- Predecir comportamiento: Saber cÃ³mo reaccionarÃ¡ ante grandes volÃºmenes de datos.

---
# ğŸ“… SEMANA 6

## âš™ï¸ Estructuras de Control

Las estructuras de control permiten gestionar el flujo de ejecuciÃ³n en un programa, determinando el orden en que las instrucciones se ejecutan. Gracias a ellas, el cÃ³digo puede tomar decisiones, repetir acciones o simplemente seguir un flujo secuencial.

### ğŸ› ï¸ Tipos de estructuras

- **Secuenciales:** Las instrucciones se ejecutan una tras otra en el orden que estÃ¡n escritas.

- **Condicionales:** Permiten que el programa tome decisiones basadas en condiciones.

  - **Simples:** Ejecutan un bloque de cÃ³digo solo si una condiciÃ³n es verdadera.

  - **Dobles:** Si la condiciÃ³n es verdadera se ejecuta un bloque, si es falsa, otro diferente.

  - **MÃºltiples:** Evaluan varias condiciones para manejar casos complejos.

- **Iterativas:** RepeticiÃ³n de instrucciones mÃºltiples veces, Ãºtil cuando no se conoce de antemano cuÃ¡ntas repeticiones se requieren.

### ğŸ¯ Objetivos

- Organizar y controlar el flujo de un algoritmo para tomar decisiones y repetir acciones.

- Mejorar la legibilidad, modularidad y eficiencia del cÃ³digo.

- Facilitar la toma de decisiones con condicionales.

- Permitir repeticiones controladas mediante bucles.

---

# ğŸ“… SEMANA 7

## ğŸ” AnÃ¡lisis del Caso Medio

El anÃ¡lisis de caso medio mide el rendimiento esperado de un algoritmo considerando todas las posibles entradas y sus probabilidades. Es una medida mÃ¡s realista que el anÃ¡lisis del mejor o peor caso.

### ğŸ§­ Proceso

1. Definir la distribuciÃ³n probabilÃ­stica de las entradas.

2. Calcular el costo de ejecuciÃ³n para cada tipo de entrada.

3. Promediar los costos ponderados por sus probabilidades.

4. Considerar el tamaÃ±o de la entrada para el cÃ¡lculo.

### âš–ï¸ Importancia

- Brinda una visiÃ³n realista del rendimiento en uso tÃ­pico.

- Facilita la comparaciÃ³n entre algoritmos.

- Ayuda a identificar oportunidades de optimizaciÃ³n.

### ğŸ§ª Ejemplo

En una bÃºsqueda lineal, el elemento puede estar en cualquier posiciÃ³n con igual probabilidad. El anÃ¡lisis calcula el promedio de comparaciones necesarias para encontrarlo.

---

## âš¡ AnÃ¡lisis Amortizado

El anÃ¡lisis amortizado evalÃºa el costo promedio de una secuencia de operaciones, en lugar de enfocarse en el costo individual mÃ¡s alto. Esto es Ãºtil cuando operaciones costosas ocurren raramente.

### ğŸ§ª Ejemplo

En una lista dinÃ¡mica, insertar puede ser O(1) usualmente, pero ocasionalmente O(n) para redimensionar. El anÃ¡lisis amortizado muestra que el costo promedio por inserciÃ³n sigue siendo O(1).

### ğŸ› ï¸ MÃ©todos comunes

- MÃ©todo de agregaciÃ³n

- MÃ©todo contable

- MÃ©todo potencial

### ğŸ¯ Importancia

Proporciona una visiÃ³n mÃ¡s realista del rendimiento en escenarios reales.

---

## ğŸ”„ Recurrencias

Una recurrencia es una ecuaciÃ³n que define una funciÃ³n en tÃ©rminos de valores menores de sÃ­ misma. Son clave para analizar algoritmos recursivos y "divide y vencerÃ¡s".

### ğŸ¯ Importancia

Permiten calcular la complejidad de algoritmos que dividen problemas en subproblemas mÃ¡s pequeÃ±os.

### ğŸ§ª Ejemplo

Factorial: T(n) = T(n-1) + 1, con T(1) = 1.

### ğŸ§® SoluciÃ³n

Se puede resolver con mÃ©todos como expansiÃ³n, maestro o sustituciÃ³n para obtener la complejidad asintÃ³tica.

### ğŸ“ˆ Complejidad

Por ejemplo, resolver una recurrencia puede mostrar que el algoritmo es O(n), es decir, crece linealmente con el tamaÃ±o de la entrada.

# ğŸ“š Semana 9: Algoritmos Voraces y Ãrbol de Recubrimiento MÃ­nimo

## âš™ï¸ Algoritmos Voraces

Los **algoritmos voraces** son una clase de algoritmos de optimizaciÃ³n que construyen soluciones paso a paso, eligiendo en cada etapa la opciÃ³n que parece ser la mejor **sin considerar efectos futuros**. Aunque su simplicidad es su principal ventaja, **no siempre garantizan una soluciÃ³n Ã³ptima global**, pero sÃ­ logran soluciones eficientes en muchos problemas prÃ¡cticos.

### ğŸ§© CaracterÃ­sticas principales:

- **ğŸ” Enfoque local:**  
  El algoritmo toma decisiones basadas en la mejor elecciÃ³n disponible en ese instante, sin revisar decisiones pasadas.

- **ğŸš« No retrospectivo:**  
  Una vez tomada una decisiÃ³n, no se revierte ni se evalÃºan caminos alternativos.

- **âš¡ Eficiencia:**  
  Suelen tener **baja complejidad computacional**, tÃ­picamente lineal o logarÃ­tmica, lo cual los hace muy rÃ¡pidos.

- **ğŸ¯ SoluciÃ³n no siempre Ã³ptima:**  
  No siempre proporcionan la mejor soluciÃ³n global, pero **pueden acercarse bastante** y ser suficientes en la prÃ¡ctica.

---

## ğŸŒ Grafos No Dirigidos

Un **grafo no dirigido** es una estructura matemÃ¡tica formada por nodos (**vÃ©rtices**) conectados por lÃ­neas (**aristas**) **sin direcciÃ³n**. Es decir, si un nodo `A` estÃ¡ conectado a un nodo `B`, entonces tambiÃ©n se considera que `B` estÃ¡ conectado a `A`.

### ğŸ“Œ Ejemplo de aplicaciÃ³n:

- Redes sociales donde la amistad es mutua.  
- Mapas de carreteras donde el trÃ¡nsito es posible en ambas direcciones.  
- Redes de contactos entre personas donde la conexiÃ³n es bidireccional.  

---

## ğŸŒ² Ãrbol de Recubrimiento MÃ­nimo

El **Ãrbol de Recubrimiento MÃ­nimo (Minimum Spanning Tree, MST)** es un subconjunto de las aristas de un grafo que conecta todos los vÃ©rtices sin formar ciclos y con el **menor peso total posible**.

Uno de los algoritmos mÃ¡s conocidos para encontrarlo es el **algoritmo de Kruskal**, el cual es un ejemplo clÃ¡sico de algoritmo voraz.

---

## ğŸ’» Ejemplo en Java: Algoritmo de Kruskal

A continuaciÃ³n, se muestra la implementaciÃ³n del algoritmo de Kruskal en Java, utilizado para encontrar el Ãrbol de Recubrimiento MÃ­nimo en un grafo no dirigido y ponderado:

```java
// Programa en Java para implementar
// el Algoritmo de Kruskal
import java.util.*;

class Arista implements Comparable<Arista> {
    int origen, destino, peso;

    public Arista(int origen, int destino, int peso) {
        this.origen = origen;
        this.destino = destino;
        this.peso = peso;
    }

    // Comparar dos aristas en base a su peso
    @Override
    public int compareTo(Arista otraArista) {
        return this.peso - otraArista.peso;
    }
}

class Grafo {
    int numVertices, numAristas;
    Arista[] aristas;

    public Grafo(int numVertices, int numAristas) {
        this.numVertices = numVertices;
        this.numAristas = numAristas;
        aristas = new Arista[numAristas];
    }

    int encontrar(int[] padre, int i) {
        if (padre[i] == -1)
            return i;
        return encontrar(padre, padre[i]);
    }

    void unir(int[] padre, int x, int y) {
        int conjuntoX = encontrar(padre, x);
        int conjuntoY = encontrar(padre, y);
        padre[conjuntoX] = conjuntoY;
    }

    void kruskalAEM() {
        Arista[] resultado = new Arista[numVertices - 1];
        int e = 0, i = 0;

        Arrays.sort(aristas);

        int[] padre = new int[numVertices];
        Arrays.fill(padre, -1);

        while (e < numVertices - 1) {
            Arista siguienteArista = aristas[i++];

            int x = encontrar(padre, siguienteArista.origen);
            int y = encontrar(padre, siguienteArista.destino);

            if (x != y) {
                resultado[e++] = siguienteArista;
                unir(padre, x, y);
            }
        }

        System.out.println("Aristas en el Ã¡rbol de expansiÃ³n mÃ­nima:");
        for (i = 0; i < e; ++i)
            System.out.println(resultado[i].origen + " - " 
                               + resultado[i].destino + ": " + resultado[i].peso);
    }
}

public class Principal {
    public static void main(String[] args) {
        int vertices = 4;
        int aristas = 5;

        Grafo grafo = new Grafo(vertices, aristas);

        grafo.aristas[0] = new Arista(0, 1, 10);
        grafo.aristas[1] = new Arista(0, 2, 6);
        grafo.aristas[2] = new Arista(0, 3, 5);
        grafo.aristas[3] = new Arista(1, 3, 15);
        grafo.aristas[4] = new Arista(2, 3, 4);

        grafo.kruskalAEM();
    }
}
```

# ğŸ“š Semana 10: Grafos Dirigidos y Algoritmo de Dijkstra

## ğŸ” Grafos Dirigidos

Los **grafos dirigidos** son estructuras de datos que representan relaciones **unidireccionales** entre elementos. A diferencia de los grafos no dirigidos, donde la conexiÃ³n entre dos nodos es mutua, en los grafos dirigidos **cada arista tiene una direcciÃ³n**, indicando un flujo especÃ­fico desde un nodo hacia otro.

### ğŸ§  Ventajas de los grafos dirigidos:

- **ğŸ¯ Modelado preciso:**  
  Representan relaciones unidireccionales con exactitud, Ãºtiles para casos donde no hay reciprocidad.

- **ğŸ“Š AnÃ¡lisis eficiente:**  
  Permiten estudiar propiedades como el flujo de informaciÃ³n, jerarquÃ­as y dependencias.

- **ğŸŒ Aplicaciones diversas:**  
  Se utilizan en:
  - Mapas de rutas con sentido Ãºnico
  - Grafos de dependencias en compiladores
  - Sistemas de recomendaciÃ³n
  - Redes sociales con relaciones de "seguimiento"

---

## ğŸš€ Algoritmo de Dijkstra

El **algoritmo de Dijkstra** es un algoritmo clÃ¡sico para encontrar el **camino mÃ¡s corto** desde un nodo origen a todos los demÃ¡s nodos en un grafo con **pesos no negativos**. Utiliza un enfoque **greedy** (voraz) y es fundamental en muchas aplicaciones como GPS, redes de computadoras y juegos.

### ğŸ§® LÃ³gica bÃ¡sica del algoritmo:
1. Inicializa todas las distancias como infinitas, excepto el nodo origen (que vale 0).
2. Selecciona el nodo no visitado con menor distancia.
3. Actualiza las distancias de sus nodos vecinos si se encuentra un camino mÃ¡s corto.
4. Repite hasta visitar todos los nodos.

---

## ğŸ’» ImplementaciÃ³n en Java

```java
import java.util.Arrays;

public class AlgoritmoDijkstra {
    static final int INF = Integer.MAX_VALUE; // Valor que representa "infinito"

    public static void dijkstra(int[][] grafo, int origen) {
        int n = grafo.length;
        int[] distancias = new int[n];
        boolean[] visitado = new boolean[n];

        Arrays.fill(distancias, INF); // Inicializa todas las distancias como infinitas
        distancias[origen] = 0;       // La distancia al nodo origen es 0

        for (int contador = 0; contador < n - 1; contador++) {
            int u = obtenerMinimaDistancia(distancias, visitado);
            visitado[u] = true;

            // Actualiza las distancias de los vÃ©rtices adyacentes al vÃ©rtice seleccionado
            for (int v = 0; v < n; v++) {
                if (!visitado[v] && grafo[u][v] != 0 && distancias[u] != INF &&
                        distancias[u] + grafo[u][v] < distancias[v]) {
                    distancias[v] = distancias[u] + grafo[u][v];
                }
            }
        }

        imprimirSolucion(distancias);
    }

    // FunciÃ³n auxiliar para encontrar el vÃ©rtice con la menor distancia aÃºn no visitado
    private static int obtenerMinimaDistancia(int[] distancias, boolean[] visitado) {
        int minimo = INF, indiceMinimo = -1;
        for (int v = 0; v < distancias.length; v++) {
            if (!visitado[v] && distancias[v] <= minimo) {
                minimo = distancias[v];
                indiceMinimo = v;
            }
        }
        return indiceMinimo;
    }

    // FunciÃ³n para imprimir la soluciÃ³n final
    private static void imprimirSolucion(int[] distancias) {
        System.out.println("Distancias mÃ¡s cortas desde el nodo origen:");
        for (int i = 0; i < distancias.length; i++) {
            System.out.println("Hacia " + i + ": " + distancias[i]);
        }
    }

    public static void main(String[] args) {
        int[][] grafo = {
                {0, 2, 0, 4, 0},
                {2, 0, 5, 0, 0},
                {0, 5, 0, 8, 0},
                {4, 0, 8, 0, 3},
                {0, 0, 0, 3, 0}
        };

        dijkstra(grafo, 0); // Ejecutar Dijkstra desde el nodo 0
    }
}
```

# ğŸ“… Semana 11: Algoritmos Divide y VencerÃ¡s

## ğŸ”ª Estrategia "Divide y VencerÃ¡s"

El paradigma **Divide y VencerÃ¡s** consiste en resolver problemas grandes dividiÃ©ndolos en subproblemas mÃ¡s pequeÃ±os y manejables, resolviÃ©ndolos recursivamente y combinando sus soluciones para construir la soluciÃ³n general.

Este enfoque es clave en muchos algoritmos eficientes, incluyendo ordenamientos, bÃºsquedas y cÃ¡lculos numÃ©ricos.

---

### ğŸ§© Componentes de la estrategia:

1. **Dividir**  
   Se parte el problema en subproblemas mÃ¡s pequeÃ±os, normalmente en partes iguales.

2. **Conquistar**  
   Se resuelven los subproblemas, generalmente mediante recursiÃ³n. Si el subproblema es lo suficientemente pequeÃ±o, se resuelve directamente (caso base).

3. **Combinar**  
   Se unen las soluciones de los subproblemas para formar la soluciÃ³n del problema original.

---

## ğŸ” Mecanismo de BÃºsqueda Binaria

La **bÃºsqueda binaria** es un claro ejemplo del enfoque Divide y VencerÃ¡s. Consiste en reducir el espacio de bÃºsqueda a la mitad en cada paso, eliminando sistemÃ¡ticamente la mitad que no contiene el elemento buscado.

### ğŸ“š Ejemplo prÃ¡ctico:

Buscar una palabra en un diccionario no implica revisar pÃ¡gina por pÃ¡gina. En su lugar, uno abre el libro por la mitad, evalÃºa, y decide si continuar a la izquierda o derecha. Este principio se aplica directamente en la bÃºsqueda binaria.

---

## ğŸ’» CÃ³digo: BÃºsqueda Binaria en Java

```java
public class Busqueda {
    public static int encontrar(int[] datos, int objetivo) {
        int inicio = 0;
        int fin = datos.length - 1;
        
        while (inicio <= fin) {
            int medio = inicio + (fin - inicio) / 2;

            if (datos[medio] == objetivo) {
                return medio;
            } else if (datos[medio] < objetivo) {
                inicio = medio + 1;
            } else {
                fin = medio - 1;
            }
        }

        return -1;
    }

    public static void main(String[] args) {
        int[] numeros = {2, 4, 6, 8, 10, 12, 14, 16};
        int buscado = 10;
        int posicion = encontrar(numeros, buscado);

        if (posicion != -1) {
            System.out.println("El nÃºmero " + buscado + " se encuentra en la posiciÃ³n: " + posicion);
        } else {
            System.out.println("El nÃºmero " + buscado + " no fue encontrado.");
        }
    }
}

```

# ğŸ“š Semana 12: Algoritmos Divide y VencerÃ¡s (Parte 2)

## ğŸ§  Consideraciones clave al usar Divide y VencerÃ¡s

Cuando se diseÃ±a un algoritmo usando este paradigma, es importante tener en cuenta varios factores para garantizar eficiencia y correcciÃ³n:

- **ğŸ§® Complejidad:**

  Es fundamental analizar la complejidad de cada una de las etapas:
  - Dividir
  - Resolver subproblemas
  - Combinar resultados
  
  Esto permite conocer el costo total del algoritmo y si es viable para conjuntos de datos grandes.

- **ğŸ” Caso base:**

  Se debe definir correctamente para evitar recursiones infinitas y garantizar que el algoritmo converja a una soluciÃ³n.

- **ğŸ§© GeneralizaciÃ³n:**

  A menudo es necesario transformar el problema para que pueda ser resuelto recursivamente. Esta reformulaciÃ³n permite una soluciÃ³n mÃ¡s simple y eficiente.

---

## ğŸ“Œ Merge Sort (Ordenamiento por FusiÃ³n)

**Merge Sort** es uno de los algoritmos mÃ¡s representativos del paradigma **Divide y VencerÃ¡s**. Se utiliza ampliamente por su rendimiento estable, incluso en el peor de los casos.

### ğŸ” Â¿CÃ³mo funciona?

1. **Divide:**

   El arreglo original se divide recursivamente por la mitad hasta que se obtienen sub-arreglos con un solo elemento (que estÃ¡n ordenados por definiciÃ³n).

2. **Conquista:**

   Al llegar a los sub-arreglos de un solo elemento, se consideran ordenados. Se inicia el proceso de combinaciÃ³n.

3. **Combina:**

   Los sub-arreglos ordenados se fusionan de manera ordenada para formar un arreglo mÃ¡s grande, tambiÃ©n ordenado. Este proceso continÃºa hasta recomponer el arreglo original, pero ahora en orden ascendente.

### âš™ï¸ Complejidad temporal

- Mejor caso: O(n log n)
- Promedio: O(n log n)
- Peor caso: O(n log n)

---

## ğŸ’» CÃ³digo en Java: Merge Sort

```java
public class OrdenamientoFusion {

    public static void ordenar(int[] arreglo, int inicio, int fin) {
        if (inicio < fin) {
            int medio = (inicio + fin) / 2;

            ordenar(arreglo, inicio, medio);
            ordenar(arreglo, medio + 1, fin);

            fusionar(arreglo, inicio, medio, fin);
        }
    }

    public static void fusionar(int[] arreglo, int inicio, int medio, int fin) {
        int tamaÃ±o1 = medio - inicio + 1;
        int tamaÃ±o2 = fin - medio;

        int[] izquierda = new int[tamaÃ±o1];
        int[] derecha = new int[tamaÃ±o2];

        for (int i = 0; i < tamaÃ±o1; ++i) {
            izquierda[i] = arreglo[inicio + i];
        }
        for (int j = 0; j < tamaÃ±o2; ++j) {
            derecha[j] = arreglo[medio + 1 + j];
        }

        int i = 0, j = 0;
        int k = inicio;

        while (i < tamaÃ±o1 && j < tamaÃ±o2) {
            if (izquierda[i] <= derecha[j]) {
                arreglo[k] = izquierda[i];
                i++;
            } else {
                arreglo[k] = derecha[j];
                j++;
            }
            k++;
        }

        while (i < tamaÃ±o1) {
            arreglo[k] = izquierda[i];
            i++;
            k++;
        }

        while (j < tamaÃ±o2) {
            arreglo[k] = derecha[j];
            j++;
            k++;
        }
    }

    public static void main(String[] args) {
        int[] datos = {12, 11, 13, 5, 6, 7};
        int n = datos.length;

        System.out.println("Arreglo original:");
        imprimir(datos);

        ordenar(datos, 0, n - 1);

        System.out.println("\nArreglo ordenado:");
        imprimir(datos);
    }

    public static void imprimir(int[] arreglo) {
        for (int valor : arreglo) {
            System.out.print(valor + " ");
        }
        System.out.println();
    }
}
```

# ğŸ“š Semana 13: Algoritmos Avanzados â€“ Mediana y ExponenciaciÃ³n RÃ¡pida

---

## ğŸ“ CÃ¡lculo de la Mediana en Dos Arreglos Ordenados

Este problema busca encontrar la **mediana** de dos arreglos ordenados sin fusionarlos completamente. La soluciÃ³n eficiente utiliza una variante de la tÃ©cnica **Divide y VencerÃ¡s**, reduciendo el tiempo de ejecuciÃ³n a **O(log(min(n, m)))**, siendo `n` y `m` los tamaÃ±os de los arreglos.

### ğŸ§  Idea principal:

En lugar de combinar completamente los dos arreglos, se busca una **particiÃ³n Ã³ptima** que divida ambos arreglos en dos mitades tal que:

- Todos los elementos en la mitad izquierda sean menores o iguales que los de la mitad derecha.
- El nÃºmero total de elementos a la izquierda sea igual al de la derecha (o difiera por uno si la cantidad total es impar).

### ğŸ§® Pasos del algoritmo:

1. Identificar el arreglo mÃ¡s pequeÃ±o para hacer la bÃºsqueda binaria sobre Ã©l.
2. Calcular una particiÃ³n para ambos arreglos.
3. Verificar si la particiÃ³n es vÃ¡lida.
4. Si lo es, calcular la mediana segÃºn el total de elementos (par o impar).
5. Si no lo es, ajustar la bÃºsqueda binaria.

### âœ… Ventajas:

- Alta eficiencia: O(log(min(n, m)))
- No requiere espacio adicional.
- Muy Ãºtil en bases de datos o flujos de datos ordenados.

---

## ğŸ”¢ ExponenciaciÃ³n RÃ¡pida (Exponentiation by Squaring)

La **exponenciaciÃ³n rÃ¡pida** es una tÃ©cnica utilizada para calcular potencias de un nÃºmero de forma eficiente, especialmente cuando el exponente es muy grande. Se basa en la propiedad:

- Si el exponente es par:  
  `a^n = (a^(n/2))^2`
- Si el exponente es impar:  
  `a^n = a * (a^((n-1)/2))^2`

### ğŸ§  Â¿Por quÃ© es Ãºtil?

- Reduce la complejidad de O(n) a O(log n)
- Fundamental en aplicaciones de criptografÃ­a y teorÃ­a de nÃºmeros.
- Evita desbordamientos y mejora el rendimiento en cÃ³mputos intensivos.

---

## ğŸ’» CÃ³digo en Java

### Mediana de dos arreglos ordenados

```java
public class MedianaDosArreglos {

    public static double encontrarMediana(int[] A, int[] B) {
        if (A.length > B.length) return encontrarMediana(B, A);

        int m = A.length;
        int n = B.length;
        int imin = 0, imax = m, mitad = (m + n + 1) / 2;

        while (imin <= imax) {
            int i = (imin + imax) / 2;
            int j = mitad - i;

            if (i < m && B[j - 1] > A[i]) {
                imin = i + 1;
            } else if (i > 0 && A[i - 1] > B[j]) {
                imax = i - 1;
            } else {
                int maxIzquierda = 0;
                if (i == 0) maxIzquierda = B[j - 1];
                else if (j == 0) maxIzquierda = A[i - 1];
                else maxIzquierda = Math.max(A[i - 1], B[j - 1]);

                if ((m + n) % 2 == 1) return maxIzquierda;

                int minDerecha = 0;
                if (i == m) minDerecha = B[j];
                else if (j == n) minDerecha = A[i];
                else minDerecha = Math.min(A[i], B[j]);

                return (maxIzquierda + minDerecha) / 2.0;
            }
        }

        return 0.0;
    }

    public static void main(String[] args) {
        int[] nums1 = {1, 3, 8};
        int[] nums2 = {7, 9, 10, 11};

        double mediana = encontrarMediana(nums1, nums2);
        System.out.println("Mediana combinada: " + mediana);
    }
}
```

### ExponenciaciÃ³n rÃ¡pida

```java
public class ExponenciacionRapida {

    public static long potencia(long base, long exponente) {
        long resultado = 1;

        while (exponente > 0) {
            if ((exponente & 1) == 1) {
                resultado *= base;
            }
            base *= base;
            exponente >>= 1; // Equivalente a dividir entre 2
        }

        return resultado;
    }

    public static void main(String[] args) {
        long base = 2;
        long exponente = 10;
        System.out.println("Resultado: " + potencia(base, exponente)); // 1024
    }
}
```

# ğŸ“š Semana 14: MultiplicaciÃ³n de Matrices

---

## âœï¸ IntroducciÃ³n

La **multiplicaciÃ³n de matrices** es una operaciÃ³n fundamental en matemÃ¡ticas, ciencias computacionales, grÃ¡ficos por computadora, inteligencia artificial y mÃ¡s. A nivel algorÃ­tmico, representa una oportunidad para analizar diferentes enfoques con distintas eficiencias computacionales.

---

## ğŸ“ DefiniciÃ³n Formal

Dadas dos matrices:

- **A** de dimensiÃ³n m x n
- **B** de dimensiÃ³n n x p

La matriz **C = A Ã— B** tendrÃ¡ dimensiÃ³n m x p, y cada elemento de **C** se calcula como:

C[i][j] = A[i][0] Ã— B[0][j] + A[i][1] Ã— B[1][j] + ... + A[i][n-1] Ã— B[n-1][j]


---

## ğŸ” Complejidad Computacional

- **Algoritmo clÃ¡sico:** O(nÂ³)
- **Algoritmo de Strassen:** O(n^2.81)
- **Algoritmos mÃ¡s avanzados:** Existen mÃ©todos incluso mÃ¡s eficientes (como Coppersmithâ€“Winograd), aunque son complejos y poco prÃ¡cticos en muchos casos reales.

---

## ğŸ§  Consideraciones importantes

- Para multiplicar dos matrices, **el nÃºmero de columnas de la primera debe coincidir con el nÃºmero de filas de la segunda**.
- La multiplicaciÃ³n **no es conmutativa**: A Ã— B â‰  B Ã— A en general.
- Se puede aplicar en cadenas de transformaciones, rotaciones, cÃ¡lculos de redes neuronales, entre otros.

---

## ğŸ’» CÃ³digo Java: MultiplicaciÃ³n ClÃ¡sica de Matrices

```java
public class StrassenMatrixMultiplication {

    public static int[][] strassen(int[][] A, int[][] B) {
        int n = A.length;
        
        // Caso base: matriz 1x1
        if (n == 1) {
            int[][] C = new int[1][1];
            C[0][0] = A[0][0] * B[0][0];
            return C;
        }

        // Dividir matrices en 4 submatrices
        int newSize = n / 2;
        int[][] A11 = new int[newSize][newSize];
        int[][] A12 = new int[newSize][newSize];
        int[][] A21 = new int[newSize][newSize];
        int[][] A22 = new int[newSize][newSize];
        int[][] B11 = new int[newSize][newSize];
        int[][] B12 = new int[newSize][newSize];
        int[][] B21 = new int[newSize][newSize];
        int[][] B22 = new int[newSize][newSize];

        // Llenar submatrices
        split(A, A11, 0, 0);
        split(A, A12, 0, newSize);
        split(A, A21, newSize, 0);
        split(A, A22, newSize, newSize);
        split(B, B11, 0, 0);
        split(B, B12, 0, newSize);
        split(B, B21, newSize, 0);
        split(B, B22, newSize, newSize);

        // Calcular M1 a M7
        int[][] M1 = strassen(add(A11, A22), add(B11, B22));
        int[][] M2 = strassen(add(A21, A22), B11);
        int[][] M3 = strassen(A11, subtract(B12, B22));
        int[][] M4 = strassen(A22, subtract(B21, B11));
        int[][] M5 = strassen(add(A11, A12), B22);
        int[][] M6 = strassen(subtract(A21, A11), add(B11, B12));
        int[][] M7 = strassen(subtract(A12, A22), add(B21, B22));

        // Calcular C submatrices
        int[][] C11 = add(subtract(add(M1, M4), M5), M7);
        int[][] C12 = add(M3, M5);
        int[][] C21 = add(M2, M4);
        int[][] C22 = add(subtract(add(M1, M3), M2), M6);

        // Combinar submatrices en matriz resultado
        int[][] C = new int[n][n];
        join(C11, C, 0, 0);
        join(C12, C, 0, newSize);
        join(C21, C, newSize, 0);
        join(C22, C, newSize, newSize);

        return C;
    }

    // Operaciones auxiliares

    public static int[][] add(int[][] A, int[][] B) {
        int n = A.length;
        int[][] result = new int[n][n];
        for (int i = 0; i < n; i++)
            for (int j = 0; j < n; j++)
                result[i][j] = A[i][j] + B[i][j];
        return result;
    }

    public static int[][] subtract(int[][] A, int[][] B) {
        int n = A.length;
        int[][] result = new int[n][n];
        for (int i = 0; i < n; i++)
            for (int j = 0; j < n; j++)
                result[i][j] = A[i][j] - B[i][j];
        return result;
    }

    public static void split(int[][] parent, int[][] child, int iB, int jB) {
        for (int i = 0; i < child.length; i++)
            for (int j = 0; j < child.length; j++)
                child[i][j] = parent[i + iB][j + jB];
    }

    public static void join(int[][] child, int[][] parent, int iB, int jB) {
        for (int i = 0; i < child.length; i++)
            for (int j = 0; j < child.length; j++)
                parent[i + iB][j + jB] = child[i][j];
    }

    // MÃ©todo de prueba
    public static void main(String[] args) {
        int[][] A = {
            {7, 6, 9, 4},
            {8, 5, 3, 2},
            {7, 7, 9, 9},
            {4, 3, 8, 5}
        };

        int[][] B = {
            {3, 2, 9, 5},
            {7, 5, 6, 4},
            {4, 6, 9, 1},
            {9, 3, 8, 7}
        };

        int[][] C = strassen(A, B);

        System.out.println("Resultado de la multiplicaciÃ³n:");
        for (int[] row : C) {
            for (int val : row)
                System.out.print(val + "\t");
            System.out.println();
        }
    }
}
```

# ğŸ“š Semana 15: Algoritmos Probabilistas

---

## ğŸ² Â¿QuÃ© son los algoritmos probabilistas?

Los **algoritmos probabilistas** son algoritmos que, durante su ejecuciÃ³n, toman decisiones basadas en valores aleatorios. Estos algoritmos no siempre garantizan el mismo resultado o tiempo de ejecuciÃ³n, pero pueden ofrecer soluciones rÃ¡pidas, aproximadas o altamente eficientes en promedio.

---

## âš™ï¸ CaracterÃ­sticas

- **Uso del azar:** Incorporan decisiones basadas en nÃºmeros aleatorios.
- **Rendimiento promedio:** Suelen ser mÃ¡s rÃ¡pidos en la prÃ¡ctica que los algoritmos deterministas.
- **No deterministas:** Pueden producir distintos resultados con la misma entrada, dependiendo del azar.
- **Alta aplicabilidad:** Utilizados en criptografÃ­a, simulaciÃ³n, optimizaciÃ³n, y machine learning.

---

## ğŸ“Œ Tipos

- **Monte Carlo:** Devuelven una respuesta probablemente correcta. Pueden errar, pero en un rango de error controlado.
- **Las Vegas:** Siempre devuelven la respuesta correcta, pero su tiempo de ejecuciÃ³n varÃ­a debido al azar.
- **Algoritmos de estimaciÃ³n:** Utilizan el azar para aproximar resultados (por ejemplo, estimar Ï€ o Ã¡reas).

---

## ğŸ¯ Ejemplo: GeneraciÃ³n de nÃºmeros aleatorios

Una de las bases de los algoritmos probabilistas es la **generaciÃ³n de nÃºmeros pseudoaleatorios**. Uno de los mÃ©todos mÃ¡s clÃ¡sicos para ello es el **mÃ©todo congruencial lineal (MCL)**.

---

## ğŸ”¢ MÃ©todo Congruencial Lineal (MCL)

Este algoritmo genera una secuencia de nÃºmeros pseudoaleatorios mediante la siguiente fÃ³rmula:

Xâ‚™â‚Šâ‚ = (a * Xâ‚™ + c) mod m


- **Xâ‚€**: semilla (valor inicial)
- **a**: multiplicador
- **c**: incremento
- **m**: mÃ³dulo
- **Xâ‚™**: n-Ã©simo nÃºmero generado

---

## ğŸ’» CÃ³digo Java: MÃ©todo Congruencial Lineal

```java
public class MetodoCongruencialLineal {

    public static int[] generarNumeros(int semilla, int a, int c, int m, int cantidad) {
        int[] numeros = new int[cantidad];
        numeros[0] = semilla;

        for (int i = 1; i < cantidad; i++) {
            numeros[i] = (a * numeros[i - 1] + c) % m;
        }

        return numeros;
    }

    public static void main(String[] args) {
        int semilla = 7;
        int a = 5;
        int c = 3;
        int m = 16;
        int cantidad = 10;

        int[] resultados = generarNumeros(semilla, a, c, m, cantidad);

        System.out.println("NÃºmeros pseudoaleatorios generados:");
        for (int num : resultados) {
            System.out.print(num + " ");
        }
    }
}
```

# REFERENCIAS BIBLIOGRÃFICAS

- Algoritmos: quÃ© son y quÃ© tipos existen - Ferrovial. (2025, 13 febrero). Ferrovial. https://www.ferrovial.com/es/stem/algoritmos/
- AnÃ¡lisis de algoritmos | Algoritmos y Estructura de Datos. (s.Â f.). https://www.luchonet.com.ar/aed/?page_id=209
- Chaves, J. (2025, 6 enero). Complejidad computacional. Diccionario InformÃ¡tico | Soporte TÃ©cnico. https://jeffrychaves.com/diccionario/complejidad-computacional/
- Learn Asymptotic Notation in Y Minutes. (s.Â f.). https://learnxinyminutes.com/es/asymptotic-notation/
- AnÃ¡lisis amortizado | Aprende ProgramaciÃ³n Competitiva. (s.Â f.). https://aprende.olimpiada-informatica.org/algoritmia-analisis-amortizado
- Â¿CuÃ¡l es la diferencia entre la notaciÃ³n de la gran O, la gran omega y la gran theta? (2024, 29 febrero). www.linkedin.com. https://es.linkedin.com/advice/3/what-difference-between-big-o-omega-theta-notation-ig29e?lang=es&lang=es
- Building, C. (s.Â f.). Best, worst, and average case analysis. https://www-complexica-com.translate.goog/narrow-ai-glossary/best-worst-average-case-analysis?_x_tr_sl=en&_x_tr_tl=es&_x_tr_hl=es&_x_tr_pto=tc
