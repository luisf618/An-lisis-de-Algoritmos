# ğŸ§  AnÃ¡lisis de Algoritmos

El anÃ¡lisis de algoritmos es una rama fundamental de la teorÃ­a de la complejidad computacional. Su objetivo es estimar teÃ³ricamente los recursos necesarios (tiempo y espacio) que un algoritmo requiere para resolver un problema especÃ­fico. Dado que la mayorÃ­a de los algoritmos estÃ¡n diseÃ±ados para manejar entradas de longitud arbitraria, es esencial determinar cÃ³mo escalan en eficiencia.

- **Complejidad de tiempo**: Relaciona la longitud de la entrada con el nÃºmero de pasos necesarios para ejecutar el algoritmo.
- **Complejidad de espacio**: Relaciona la longitud de la entrada con la cantidad de memoria requerida durante la ejecuciÃ³n.

---

# ğŸ”§ Algoritmo

Un algoritmo es una secuencia clara y ordenada de pasos que, al seguirse, permite resolver un problema o realizar una tarea especÃ­fica. Son esenciales en programaciÃ³n y se aplican en diversas Ã¡reas, desde la cocina hasta la inteligencia artificial.

En informÃ¡tica, un algoritmo es un conjunto de instrucciones definidas, ordenadas y finitas que permiten resolver un problema, realizar un cÃ¡lculo o llevar a cabo una tarea. Es decir, es un procedimiento paso a paso para alcanzar un objetivo. A partir de un estado e informaciÃ³n iniciales, se siguen pasos ordenados hasta llegar a la soluciÃ³n.

> ğŸ’¡ **Nota**: En programaciÃ³n, diseÃ±ar un algoritmo es el paso previo a escribir el cÃ³digo.

## ğŸ“ Ejemplos

- **Recetas de cocina**: Explican paso a paso cÃ³mo preparar un platillo.
- **Instrucciones de ensamblaje**: Como las de armar un set de LEGO, detallan cada paso para construir una figura.
- **Manuales de usuario**: GuÃ­an al usuario en la configuraciÃ³n o uso de dispositivos.

---

# ğŸ§® Algoritmia

La algoritmia es la ciencia que estudia los algoritmos, es decir, conjuntos de instrucciones que permiten resolver problemas o realizar tareas. Se enfoca en el diseÃ±o, anÃ¡lisis y eficiencia de los algoritmos, buscando la mejor manera de solucionar problemas de forma automÃ¡tica.

## ğŸ¯ Objetivos

- DiseÃ±ar algoritmos eficientes que resuelvan problemas de forma Ã³ptima, utilizando la menor cantidad de recursos (tiempo y memoria).
- Analizar la eficiencia de los algoritmos, determinando su tiempo de ejecuciÃ³n y espacio de memoria requerido.
- Desarrollar herramientas y tÃ©cnicas para la creaciÃ³n de algoritmos, como pseudocÃ³digo o diagramas de flujo.

## ğŸ§ª Casos de Entrada

- **Mejor caso**: SituaciÃ³n mÃ¡s favorable para el algoritmo, donde el tiempo de ejecuciÃ³n o el espacio requerido son mÃ­nimos.
- **Caso promedio**: Tiempo de ejecuciÃ³n o espacio requerido para una entrada aleatoria tÃ­pica.
- **Peor caso**: SituaciÃ³n mÃ¡s desfavorable para el algoritmo, donde el tiempo de ejecuciÃ³n o el espacio requerido son mÃ¡ximos.

## ğŸ§° Tipos de AnÃ¡lisis

- **Cuantitativos y cualitativos**: Basados en cÃ¡lculos matemÃ¡ticos o secuencias lÃ³gicas.
- **Computacionales o no computacionales**: Dependiendo de si requieren o no el uso de un ordenador.
- **Algoritmos de bÃºsqueda**: Encuentran elementos con ciertas propiedades dentro de una estructura de datos.
- **Algoritmos de ordenamiento**: Reorganizan elementos de una lista siguiendo un orden numÃ©rico o alfanumÃ©rico.
- **Algoritmos voraces**: Aplicados a problemas de optimizaciÃ³n, toman decisiones lÃ³gicas para llegar a una soluciÃ³n global. No son reversibles una vez ejecutados.
- **ProgramaciÃ³n dinÃ¡mica**: La soluciÃ³n de un problema depende de soluciones a subproblemas mÃ¡s pequeÃ±os.
- **Algoritmos probabilÃ­sticos**: Basan sus resultados en el azar, buscando obtener buenas soluciones para cualquier distribuciÃ³n aleatoria de entradas.

---

# ğŸ§© Complejidad Computacional

La complejidad computacional es una Ã¡rea clave en informÃ¡tica que estudia los recursos necesarios para resolver problemas computacionales, enfocÃ¡ndose en:

- **Tiempo**: Cantidad de pasos necesarios para llegar a una soluciÃ³n.
- **Espacio**: Cantidad de memoria que un algoritmo necesita durante su ejecuciÃ³n.

---

# ğŸ“… SEMANA 1

## ğŸ§  Algoritmia Elemental

Introduce conceptos bÃ¡sicos como eficiencia, anÃ¡lisis de casos y algoritmos simples (bÃºsqueda lineal, binaria, ordenamientos). TambiÃ©n incluye la comprensiÃ³n de operaciones bÃ¡sicas y estructuras de control, como bucles y sentencias condicionales.

### ğŸ”¤ NotaciÃ³n

- **PseudocÃ³digo**: RepresentaciÃ³n textual de un algoritmo.
- **Diagramas de flujo**: RepresentaciÃ³n visual de los pasos de un algoritmo.

### ğŸ“ IntroducciÃ³n MatemÃ¡tica

La matemÃ¡tica en algoritmia elemental se basa en operaciones bÃ¡sicas para resolver problemas de manera estructurada y lÃ³gica. Un algoritmo es una serie de instrucciones claras y ordenadas que permiten resolver un problema especÃ­fico.

### âš ï¸ ContradicciÃ³n

Una contradicciÃ³n ocurre cuando las declaraciones lÃ³gicas dentro de un algoritmo son incompatibles o producen resultados opuestos.

---

# ğŸ“… SEMANA 2

## âš™ï¸ Eficiencia de los Algoritmos

La eficiencia de un algoritmo se refiere a su capacidad para resolver problemas de manera Ã³ptima en tÃ©rminos de tiempo y espacio de memoria.

Medir la eficiencia ayuda a predecir el comportamiento del algoritmo y a compararlo con otros, mejorando la resoluciÃ³n de problemas y la gestiÃ³n de datos.

## ğŸ“Š Caso Medio

Representa el rendimiento promedio de un algoritmo considerando todas las entradas posibles y sus probabilidades.

### ğŸ§ª Ejemplo:

En una bÃºsqueda lineal en una lista:

- **Mejor caso**: El elemento buscado es el primero â†’ 1 comparaciÃ³n.
- **Peor caso**: El elemento es el Ãºltimo o no estÃ¡ â†’ n comparaciones.
- **Caso medio**: Aproximadamente n/2 comparaciones.

---

# ğŸ“… SEMANA 3

## ğŸš¨ Peor Caso

El peor caso representa el escenario mÃ¡s desfavorable en la ejecuciÃ³n de un algoritmo. Este anÃ¡lisis determina el mÃ¡ximo de recursos (tiempo o memoria) que puede consumir un algoritmo.

### ğŸ§­ Importancia

- **GarantÃ­a de rendimiento**: Saber cuÃ¡nto puede tardar como mÃ¡ximo.
- **Toma de decisiones**: Ãštil en sistemas donde el tiempo de respuesta es crÃ­tico.
- **OptimizaciÃ³n**: Permite mejorar algoritmos al conocer sus lÃ­mites.

### ğŸ§ª Ejemplo:

En una **bÃºsqueda secuencial**:

- **Peor caso**: El elemento no estÃ¡ en la lista â†’ se recorren los `n` elementos.

En **ordenamiento por selecciÃ³n (selection sort)**:

- Siempre realiza la misma cantidad de comparaciones, sin importar el orden â†’ el peor caso es igual al caso promedio.

### ğŸ“Œ NotaciÃ³n Big-O (O-grande)

La notaciÃ³n Big-O se utiliza para describir el comportamiento del algoritmo en el peor de los casos. Ejemplos:

- BÃºsqueda lineal: O(n)
- BÃºsqueda binaria: O(log n)
- Ordenamiento burbuja: O(nÂ²)
- Ordenamiento rÃ¡pido (QuickSort): O(nÂ²) en el peor caso, pero en promedio O(n log n)

---
# ğŸ“š Semana 4: NotaciÃ³n para el Orden (Big O)

## ğŸ” Â¿QuÃ© es la notaciÃ³n Big O?

Es una notaciÃ³n asintÃ³tica que describe la eficiencia de un algoritmo en funciÃ³n del tamaÃ±o de la entrada **n**.

Se centra en el crecimiento del tiempo o espacio requerido cuando la entrada aumenta.

Representa la cota superior del rendimiento del algoritmo (peor caso).

## ğŸ“Œ Ejemplos comunes

| NotaciÃ³n   | Nombre        | DescripciÃ³n breve                                      |
|------------|---------------|-------------------------------------------------------|
| O(1)       | Constante     | No depende del tamaÃ±o de la entrada.                  |
| O(n)       | Lineal        | Crece proporcionalmente a **n**.                      |
| O(log n)   | LogarÃ­tmica   | Crece lentamente, incluso si **n** aumenta mucho.     |
| O(n log n) | Quasilineal   | MÃ¡s rÃ¡pido que cuadrÃ¡tico, comÃºn en algoritmos de ordenamiento. |
| O(nÂ²)      | CuadrÃ¡tica    | Tiempo crece con el cuadrado del tamaÃ±o de entrada.    |
| O(2â¿)      | Exponencial   | Muy ineficiente; crece rÃ¡pidamente.                    |
| O(n!)      | Factorial     | Extremadamente ineficiente, tÃ­pico en algoritmos de fuerza bruta. |

## ğŸ§  Elementos clave

- Se expresa como **O(g(n))**, donde *g(n)* es una funciÃ³n que representa el crecimiento del algoritmo.
- Proporciona una cota superior, asegurando que no se necesitarÃ¡n mÃ¡s recursos que *g(n)* para entradas grandes.

---

# ğŸ“š Semana 5: Notaciones Î© (Omega) y Î˜ (Theta)

## ğŸ” Â¿QuÃ© es la notaciÃ³n Î© (Omega)?

Describe la **cota inferior** de un algoritmo, es decir, el mejor caso posible.

Asegura que el algoritmo tomarÃ¡ al menos esa cantidad de recursos para entradas grandes.

### ğŸ§  Ejemplo:

Si un algoritmo tiene **Î©(n)**, en el mejor de los casos requiere al menos **n** pasos para completarse.

## ğŸ” Â¿QuÃ© es la notaciÃ³n Î˜ (Theta)?

Describe un lÃ­mite ajustado (superior e inferior).

El algoritmo siempre tarda un tiempo proporcional a **g(n)** (ni mÃ¡s, ni menos asintÃ³ticamente).

### ğŸ¯ InterpretaciÃ³n

- **Cota estricta:** El tiempo de ejecuciÃ³n estÃ¡ acotado por arriba y por abajo.
- **Rendimiento promedio:** Representa bien el caso medio o comportamiento tÃ­pico.

### Ejemplo:

Un algoritmo con **Î˜(n log n)** se comporta asÃ­ en la mayorÃ­a de los casos, no solo en el peor o mejor.

---

## ğŸ“Œ NotaciÃ³n asintÃ³tica condicional

### ğŸ”§ Â¿QuÃ© es?

MÃ©todo para describir cÃ³mo un algoritmo escala con el tamaÃ±o de la entrada.

Se aplica a tiempo y espacio.

### ğŸ§  Â¿Para quÃ© sirve?

- Comparar algoritmos: Determinar cuÃ¡l es mÃ¡s eficiente.
- Simplificar anÃ¡lisis: Ignorar detalles menores y centrarse en el crecimiento.
- Predecir comportamiento: Saber cÃ³mo reaccionarÃ¡ ante grandes volÃºmenes de datos.

---
# ğŸ“… SEMANA 6

## âš™ï¸ Estructuras de Control

Las estructuras de control permiten gestionar el flujo de ejecuciÃ³n en un programa, determinando el orden en que las instrucciones se ejecutan. Gracias a ellas, el cÃ³digo puede tomar decisiones, repetir acciones o simplemente seguir un flujo secuencial.

### ğŸ› ï¸ Tipos de estructuras

- **Secuenciales:** Las instrucciones se ejecutan una tras otra en el orden que estÃ¡n escritas.

- **Condicionales:** Permiten que el programa tome decisiones basadas en condiciones.

  - **Simples:** Ejecutan un bloque de cÃ³digo solo si una condiciÃ³n es verdadera.

  - **Dobles:** Si la condiciÃ³n es verdadera se ejecuta un bloque, si es falsa, otro diferente.

  - **MÃºltiples:** Evaluan varias condiciones para manejar casos complejos.

- **Iterativas:** RepeticiÃ³n de instrucciones mÃºltiples veces, Ãºtil cuando no se conoce de antemano cuÃ¡ntas repeticiones se requieren.

### ğŸ¯ Objetivos

- Organizar y controlar el flujo de un algoritmo para tomar decisiones y repetir acciones.

- Mejorar la legibilidad, modularidad y eficiencia del cÃ³digo.

- Facilitar la toma de decisiones con condicionales.

- Permitir repeticiones controladas mediante bucles.

---

# ğŸ“… SEMANA 7

## ğŸ” AnÃ¡lisis del Caso Medio

El anÃ¡lisis de caso medio mide el rendimiento esperado de un algoritmo considerando todas las posibles entradas y sus probabilidades. Es una medida mÃ¡s realista que el anÃ¡lisis del mejor o peor caso.

### ğŸ§­ Proceso

1. Definir la distribuciÃ³n probabilÃ­stica de las entradas.

2. Calcular el costo de ejecuciÃ³n para cada tipo de entrada.

3. Promediar los costos ponderados por sus probabilidades.

4. Considerar el tamaÃ±o de la entrada para el cÃ¡lculo.

### âš–ï¸ Importancia

- Brinda una visiÃ³n realista del rendimiento en uso tÃ­pico.

- Facilita la comparaciÃ³n entre algoritmos.

- Ayuda a identificar oportunidades de optimizaciÃ³n.

### ğŸ§ª Ejemplo

En una bÃºsqueda lineal, el elemento puede estar en cualquier posiciÃ³n con igual probabilidad. El anÃ¡lisis calcula el promedio de comparaciones necesarias para encontrarlo.

---

## âš¡ AnÃ¡lisis Amortizado

El anÃ¡lisis amortizado evalÃºa el costo promedio de una secuencia de operaciones, en lugar de enfocarse en el costo individual mÃ¡s alto. Esto es Ãºtil cuando operaciones costosas ocurren raramente.

### ğŸ§ª Ejemplo

En una lista dinÃ¡mica, insertar puede ser O(1) usualmente, pero ocasionalmente O(n) para redimensionar. El anÃ¡lisis amortizado muestra que el costo promedio por inserciÃ³n sigue siendo O(1).

### ğŸ› ï¸ MÃ©todos comunes

- MÃ©todo de agregaciÃ³n

- MÃ©todo contable

- MÃ©todo potencial

### ğŸ¯ Importancia

Proporciona una visiÃ³n mÃ¡s realista del rendimiento en escenarios reales.

---

## ğŸ”„ Recurrencias

Una recurrencia es una ecuaciÃ³n que define una funciÃ³n en tÃ©rminos de valores menores de sÃ­ misma. Son clave para analizar algoritmos recursivos y "divide y vencerÃ¡s".

### ğŸ¯ Importancia

Permiten calcular la complejidad de algoritmos que dividen problemas en subproblemas mÃ¡s pequeÃ±os.

### ğŸ§ª Ejemplo

Factorial: T(n) = T(n-1) + 1, con T(1) = 1.

### ğŸ§® SoluciÃ³n

Se puede resolver con mÃ©todos como expansiÃ³n, maestro o sustituciÃ³n para obtener la complejidad asintÃ³tica.

### ğŸ“ˆ Complejidad

Por ejemplo, resolver una recurrencia puede mostrar que el algoritmo es O(n), es decir, crece linealmente con el tamaÃ±o de la entrada.

# ğŸ“… SEMANA 9

## Algoritmos Voraces

Son un tipo de algoritmo de optimizaciÃ³n que toma decisiones basadas en la mejor opciÃ³n disponible en cada paso, sin considerar el impacto futuro de esas decisiones. A pesar de su simplicidad, no siempre garantiza la soluciÃ³n Ã³ptima global, pero puede ser eficiente para encontrar buenas soluciones en muchos problemas. 

### CaracterÃ­sticas principales:

- **Enfoque local:**
  
  Se centra en la mejor opciÃ³n en cada momento, sin mirar hacia atrÃ¡s o considerar las consecuencias a largo plazo.

- **No retrospectivo:**

  Una vez tomada una decisiÃ³n, no se reconsidera ni se intenta modificar.

- **Eficiencia:**

  Suelen ser rÃ¡pidos y eficientes, a menudo con complejidad temporal lineal o logarÃ­tmica.

- **No siempre Ã³ptimo:**

  No garantizan la soluciÃ³n Ã³ptima global en todos los casos, aunque pueden producir resultados cercanos a la optimalidad. 

## Grafos no dirigidos:

  Son una estructura matemÃ¡tica donde los nodos (vÃ©rtices) estÃ¡n conectados por lÃ­neas (aristas) que no tienen direcciÃ³n. Esto significa que la relaciÃ³n entre dos nodos conectados es bidireccional; si el nodo A estÃ¡ conectado al nodo B, tambiÃ©n se considera que el nodo B estÃ¡ conectado al nodo A. En esencia, no hay un sentido definido en la conexiÃ³n, a diferencia de los grafos dirigidos donde las aristas tienen una direcciÃ³n especÃ­fica.

### Ejemplo:

Redes sociales donde la amistad es mutua, mapas de carreteras donde las carreteras conectan ciudades en ambas direcciones, o redes de contactos donde si dos personas son contactos, se consideran mutuamente conectados. 

## Arbol de recubrimiento mÃ­nimo:

Este codigo es el algoritmo de Kruskal implementado en java

```java
// Programa en Java para implementar
// el Algoritmo de Kruskal
import java.util.*;

class Arista implements Comparable<Arista> {
    int origen, destino, peso;

    public Arista(int origen, int destino, int peso) {
        this.origen = origen;
        this.destino = destino;
        this.peso = peso;
    }

    // Comparar dos aristas en base a su peso
    @Override
    public int compareTo(Arista otraArista) {
        return this.peso - otraArista.peso;
    }
}

class Grafo {
    int numVertices, numAristas;
    Arista[] aristas;

    // Constructor
    public Grafo(int numVertices, int numAristas) {
        this.numVertices = numVertices;
        this.numAristas = numAristas;
        aristas = new Arista[numAristas];
    }

    // FunciÃ³n para encontrar el conjunto de un elemento
    int encontrar(int[] padre, int i) {
        if (padre[i] == -1)
            return i;
        return encontrar(padre, padre[i]);
    }

    // FunciÃ³n para unir dos conjuntos
    void unir(int[] padre, int x, int y) {
        int conjuntoX = encontrar(padre, x);
        int conjuntoY = encontrar(padre, y);
        padre[conjuntoX] = conjuntoY;
    }

    // FunciÃ³n para ejecutar el algoritmo de Kruskal y encontrar el Ã¡rbol de expansiÃ³n mÃ­nima
    void kruskalAEM() {
        Arista[] resultado = new Arista[numVertices - 1];
        int e = 0; // Ãndice para resultado[]
        int i = 0; // Ãndice para aristas ordenadas

        // Ordenar todas las aristas por peso en orden creciente
        Arrays.sort(aristas);

        int[] padre = new int[numVertices];
        Arrays.fill(padre, -1);

        // Se deben tomar exactamente (nÃºmero de vÃ©rtices - 1) aristas
        while (e < numVertices - 1) {
            Arista siguienteArista = aristas[i++];

            int x = encontrar(padre, siguienteArista.origen);
            int y = encontrar(padre, siguienteArista.destino);

            if (x != y) {
                resultado[e++] = siguienteArista;
                unir(padre, x, y);
            }
        }

        // Imprimir el Ã¡rbol de expansiÃ³n mÃ­nima
        System.out.println("Aristas en el Ã¡rbol de expansiÃ³n mÃ­nima:");
        for (i = 0; i < e; ++i)
            System.out.println(resultado[i].origen + " - " 
                               + resultado[i].destino + ": " + resultado[i].peso);
    }
}

public class Principal {
    public static void main(String[] args) {
        int vertices = 4; // NÃºmero de vÃ©rtices
        int aristas = 5;  // NÃºmero de aristas

        Grafo grafo = new Grafo(vertices, aristas);

        // Agregar aristas
        grafo.aristas[0] = new Arista(0, 1, 10);
        grafo.aristas[1] = new Arista(0, 2, 6);
        grafo.aristas[2] = new Arista(0, 3, 5);
        grafo.aristas[3] = new Arista(1, 3, 15);
        grafo.aristas[4] = new Arista(2, 3, 4);

        // Ejecutar el algoritmo de Kruskal
        grafo.kruskalAEM();
    }
}
```

# ğŸ“… SEMANA 10

## Grafos no dirigidos:

Son una estructura de datos que representa relaciones entre elementos, donde cada relaciÃ³n (arista) tiene una direcciÃ³n especÃ­fica, indicando un camino de un elemento (vÃ©rtice) a otro. A diferencia de los grafos no dirigidos, donde las relaciones son bidireccionales, los grafos dirigidos representan relaciones unidireccionales, como el flujo de trÃ¡fico en una calle o las dependencias en un proyecto de software.

### Ventajas de usar grafos dirigidos:
- **Modelado preciso:

  Permiten representar relaciones unidireccionales de manera precisa, lo que no es posible con grafos no dirigidos. 

- **AnÃ¡lisis eficiente:**

  Facilitan el anÃ¡lisis de propiedades especÃ­ficas de las relaciones, como la direcciÃ³n del flujo o las dependencias. 

- **Aplicaciones diversas:**

  Se utilizan en una amplia gama de aplicaciones, desde redes sociales hasta sistemas de recomendaciÃ³n.

## Algoritmo de Dijkstra

Algoritmo implementado en java

```java
import java.util.Arrays;

public class AlgoritmoDijkstra {
    static final int INF = Integer.MAX_VALUE; // Valor que representa "infinito"

    public static void dijkstra(int[][] grafo, int origen) {
        int n = grafo.length;
        int[] distancias = new int[n];
        boolean[] visitado = new boolean[n];

        Arrays.fill(distancias, INF); // Inicializa todas las distancias como infinitas
        distancias[origen] = 0;       // La distancia al nodo origen es 0

        for (int contador = 0; contador < n - 1; contador++) {
            int u = obtenerMinimaDistancia(distancias, visitado);
            visitado[u] = true;

            // Actualiza las distancias de los vÃ©rtices adyacentes al vÃ©rtice seleccionado
            for (int v = 0; v < n; v++) {
                if (!visitado[v] && grafo[u][v] != 0 && distancias[u] != INF &&
                        distancias[u] + grafo[u][v] < distancias[v]) {
                    distancias[v] = distancias[u] + grafo[u][v];
                }
            }
        }

        imprimirSolucion(distancias);
    }

    // FunciÃ³n auxiliar para encontrar el vÃ©rtice con la menor distancia aÃºn no visitado
    private static int obtenerMinimaDistancia(int[] distancias, boolean[] visitado) {
        int minimo = INF, indiceMinimo = -1;
        for (int v = 0; v < distancias.length; v++) {
            if (!visitado[v] && distancias[v] <= minimo) {
                minimo = distancias[v];
                indiceMinimo = v;
            }
        }
        return indiceMinimo;
    }

    // FunciÃ³n para imprimir la soluciÃ³n final
    private static void imprimirSolucion(int[] distancias) {
        System.out.println("Distancias mÃ¡s cortas desde el nodo origen:");
        for (int i = 0; i < distancias.length; i++) {
            System.out.println("Hacia " + i + ": " + distancias[i]);
        }
    }

    public static void main(String[] args) {
        int[][] grafo = {
                {0, 2, 0, 4, 0},
                {2, 0, 5, 0, 0},
                {0, 5, 0, 8, 0},
                {4, 0, 8, 0, 3},
                {0, 0, 0, 3, 0}
        };

        dijkstra(grafo, 0); // Ejecutar Dijkstra desde el nodo 0
    }
}
```



# REFERENCIAS BIBLIOGRÃFICAS

- Algoritmos: quÃ© son y quÃ© tipos existen - Ferrovial. (2025, 13 febrero). Ferrovial. https://www.ferrovial.com/es/stem/algoritmos/
- AnÃ¡lisis de algoritmos | Algoritmos y Estructura de Datos. (s.Â f.). https://www.luchonet.com.ar/aed/?page_id=209
- Chaves, J. (2025, 6 enero). Complejidad computacional. Diccionario InformÃ¡tico | Soporte TÃ©cnico. https://jeffrychaves.com/diccionario/complejidad-computacional/
- Learn Asymptotic Notation in Y Minutes. (s.Â f.). https://learnxinyminutes.com/es/asymptotic-notation/
- AnÃ¡lisis amortizado | Aprende ProgramaciÃ³n Competitiva. (s.Â f.). https://aprende.olimpiada-informatica.org/algoritmia-analisis-amortizado
- Â¿CuÃ¡l es la diferencia entre la notaciÃ³n de la gran O, la gran omega y la gran theta? (2024, 29 febrero). www.linkedin.com. https://es.linkedin.com/advice/3/what-difference-between-big-o-omega-theta-notation-ig29e?lang=es&lang=es
- Building, C. (s.Â f.). Best, worst, and average case analysis. https://www-complexica-com.translate.goog/narrow-ai-glossary/best-worst-average-case-analysis?_x_tr_sl=en&_x_tr_tl=es&_x_tr_hl=es&_x_tr_pto=tc
