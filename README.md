# ğŸ§  AnÃ¡lisis de Algoritmos

El anÃ¡lisis de algoritmos es una rama fundamental de la teorÃ­a de la complejidad computacional. Su objetivo es estimar teÃ³ricamente los recursos necesarios (tiempo y espacio) que un algoritmo requiere para resolver un problema especÃ­fico. Dado que la mayorÃ­a de los algoritmos estÃ¡n diseÃ±ados para manejar entradas de longitud arbitraria, es esencial determinar cÃ³mo escalan en eficiencia.

- **Complejidad de tiempo**: Relaciona la longitud de la entrada con el nÃºmero de pasos necesarios para ejecutar el algoritmo.
- **Complejidad de espacio**: Relaciona la longitud de la entrada con la cantidad de memoria requerida durante la ejecuciÃ³n.

---

# ğŸ”§ Algoritmo

Un algoritmo es una secuencia clara y ordenada de pasos que, al seguirse, permite resolver un problema o realizar una tarea especÃ­fica. Son esenciales en programaciÃ³n y se aplican en diversas Ã¡reas, desde la cocina hasta la inteligencia artificial.

En informÃ¡tica, un algoritmo es un conjunto de instrucciones definidas, ordenadas y finitas que permiten resolver un problema, realizar un cÃ¡lculo o llevar a cabo una tarea. Es decir, es un procedimiento paso a paso para alcanzar un objetivo. A partir de un estado e informaciÃ³n iniciales, se siguen pasos ordenados hasta llegar a la soluciÃ³n.

> ğŸ’¡ **Nota**: En programaciÃ³n, diseÃ±ar un algoritmo es el paso previo a escribir el cÃ³digo.

## ğŸ“ Ejemplos

- **Recetas de cocina**: Explican paso a paso cÃ³mo preparar un platillo.
- **Instrucciones de ensamblaje**: Como las de armar un set de LEGO, detallan cada paso para construir una figura.
- **Manuales de usuario**: GuÃ­an al usuario en la configuraciÃ³n o uso de dispositivos.

---

# ğŸ§® Algoritmia

La algoritmia es la ciencia que estudia los algoritmos, es decir, conjuntos de instrucciones que permiten resolver problemas o realizar tareas. Se enfoca en el diseÃ±o, anÃ¡lisis y eficiencia de los algoritmos, buscando la mejor manera de solucionar problemas de forma automÃ¡tica.

## ğŸ¯ Objetivos

- DiseÃ±ar algoritmos eficientes que resuelvan problemas de forma Ã³ptima, utilizando la menor cantidad de recursos (tiempo y memoria).
- Analizar la eficiencia de los algoritmos, determinando su tiempo de ejecuciÃ³n y espacio de memoria requerido.
- Desarrollar herramientas y tÃ©cnicas para la creaciÃ³n de algoritmos, como pseudocÃ³digo o diagramas de flujo.

## ğŸ§ª Casos de Entrada

- **Mejor caso**: SituaciÃ³n mÃ¡s favorable para el algoritmo, donde el tiempo de ejecuciÃ³n o el espacio requerido son mÃ­nimos.
- **Caso promedio**: Tiempo de ejecuciÃ³n o espacio requerido para una entrada aleatoria tÃ­pica.
- **Peor caso**: SituaciÃ³n mÃ¡s desfavorable para el algoritmo, donde el tiempo de ejecuciÃ³n o el espacio requerido son mÃ¡ximos.

## ğŸ§° Tipos de AnÃ¡lisis

- **Cuantitativos y cualitativos**: Basados en cÃ¡lculos matemÃ¡ticos o secuencias lÃ³gicas.
- **Computacionales o no computacionales**: Dependiendo de si requieren o no el uso de un ordenador.
- **Algoritmos de bÃºsqueda**: Encuentran elementos con ciertas propiedades dentro de una estructura de datos.
- **Algoritmos de ordenamiento**: Reorganizan elementos de una lista siguiendo un orden numÃ©rico o alfanumÃ©rico.
- **Algoritmos voraces**: Aplicados a problemas de optimizaciÃ³n, toman decisiones lÃ³gicas para llegar a una soluciÃ³n global. No son reversibles una vez ejecutados.
- **ProgramaciÃ³n dinÃ¡mica**: La soluciÃ³n de un problema depende de soluciones a subproblemas mÃ¡s pequeÃ±os.
- **Algoritmos probabilÃ­sticos**: Basan sus resultados en el azar, buscando obtener buenas soluciones para cualquier distribuciÃ³n aleatoria de entradas.

---

# ğŸ§© Complejidad Computacional

La complejidad computacional es una Ã¡rea clave en informÃ¡tica que estudia los recursos necesarios para resolver problemas computacionales, enfocÃ¡ndose en:

- **Tiempo**: Cantidad de pasos necesarios para llegar a una soluciÃ³n.
- **Espacio**: Cantidad de memoria que un algoritmo necesita durante su ejecuciÃ³n.

---

# ğŸ“… SEMANA 1

## ğŸ§  Algoritmia Elemental

Introduce conceptos bÃ¡sicos como eficiencia, anÃ¡lisis de casos y algoritmos simples (bÃºsqueda lineal, binaria, ordenamientos). TambiÃ©n incluye la comprensiÃ³n de operaciones bÃ¡sicas y estructuras de control, como bucles y sentencias condicionales.

### ğŸ”¤ NotaciÃ³n

- **PseudocÃ³digo**: RepresentaciÃ³n textual de un algoritmo.
- **Diagramas de flujo**: RepresentaciÃ³n visual de los pasos de un algoritmo.

### ğŸ“ IntroducciÃ³n MatemÃ¡tica

La matemÃ¡tica en algoritmia elemental se basa en operaciones bÃ¡sicas para resolver problemas de manera estructurada y lÃ³gica. Un algoritmo es una serie de instrucciones claras y ordenadas que permiten resolver un problema especÃ­fico.

### âš ï¸ ContradicciÃ³n

Una contradicciÃ³n ocurre cuando las declaraciones lÃ³gicas dentro de un algoritmo son incompatibles o producen resultados opuestos.

---

# ğŸ“… SEMANA 2

## âš™ï¸ Eficiencia de los Algoritmos

La eficiencia de un algoritmo se refiere a su capacidad para resolver problemas de manera Ã³ptima en tÃ©rminos de tiempo y espacio de memoria.

Medir la eficiencia ayuda a predecir el comportamiento del algoritmo y a compararlo con otros, mejorando la resoluciÃ³n de problemas y la gestiÃ³n de datos.

## ğŸ“Š Caso Medio

Representa el rendimiento promedio de un algoritmo considerando todas las entradas posibles y sus probabilidades.

### ğŸ§ª Ejemplo:

En una bÃºsqueda lineal en una lista:

- **Mejor caso**: El elemento buscado es el primero â†’ 1 comparaciÃ³n.
- **Peor caso**: El elemento es el Ãºltimo o no estÃ¡ â†’ n comparaciones.
- **Caso medio**: Aproximadamente n/2 comparaciones.

---

# ğŸ“… SEMANA 3

## ğŸš¨ Peor Caso

El peor caso representa el escenario mÃ¡s desfavorable en la ejecuciÃ³n de un algoritmo. Este anÃ¡lisis determina el mÃ¡ximo de recursos (tiempo o memoria) que puede consumir un algoritmo.

### ğŸ§­ Importancia

- **GarantÃ­a de rendimiento**: Saber cuÃ¡nto puede tardar como mÃ¡ximo.
- **Toma de decisiones**: Ãštil en sistemas donde el tiempo de respuesta es crÃ­tico.
- **OptimizaciÃ³n**: Permite mejorar algoritmos al conocer sus lÃ­mites.

### ğŸ§ª Ejemplo:

En una **bÃºsqueda secuencial**:

- **Peor caso**: El elemento no estÃ¡ en la lista â†’ se recorren los `n` elementos.

En **ordenamiento por selecciÃ³n (selection sort)**:

- Siempre realiza la misma cantidad de comparaciones, sin importar el orden â†’ el peor caso es igual al caso promedio.

### ğŸ“Œ NotaciÃ³n Big-O (O-grande)

La notaciÃ³n Big-O se utiliza para describir el comportamiento del algoritmo en el peor de los casos. Ejemplos:

- BÃºsqueda lineal: O(n)
- BÃºsqueda binaria: O(log n)
- Ordenamiento burbuja: O(nÂ²)
- Ordenamiento rÃ¡pido (QuickSort): O(nÂ²) en el peor caso, pero en promedio O(n log n)

---
# ğŸ“š Semana 4: NotaciÃ³n para el Orden (Big O)

## ğŸ” Â¿QuÃ© es la notaciÃ³n Big O?

Es una notaciÃ³n asintÃ³tica que describe la eficiencia de un algoritmo en funciÃ³n del tamaÃ±o de la entrada **n**.

Se centra en el crecimiento del tiempo o espacio requerido cuando la entrada aumenta.

Representa la cota superior del rendimiento del algoritmo (peor caso).

## ğŸ“Œ Ejemplos comunes

| NotaciÃ³n   | Nombre        | DescripciÃ³n breve                                      |
|------------|---------------|-------------------------------------------------------|
| O(1)       | Constante     | No depende del tamaÃ±o de la entrada.                  |
| O(n)       | Lineal        | Crece proporcionalmente a **n**.                      |
| O(log n)   | LogarÃ­tmica   | Crece lentamente, incluso si **n** aumenta mucho.     |
| O(n log n) | Quasilineal   | MÃ¡s rÃ¡pido que cuadrÃ¡tico, comÃºn en algoritmos de ordenamiento. |
| O(nÂ²)      | CuadrÃ¡tica    | Tiempo crece con el cuadrado del tamaÃ±o de entrada.    |
| O(2â¿)      | Exponencial   | Muy ineficiente; crece rÃ¡pidamente.                    |
| O(n!)      | Factorial     | Extremadamente ineficiente, tÃ­pico en algoritmos de fuerza bruta. |

## ğŸ§  Elementos clave

- Se expresa como **O(g(n))**, donde *g(n)* es una funciÃ³n que representa el crecimiento del algoritmo.
- Proporciona una cota superior, asegurando que no se necesitarÃ¡n mÃ¡s recursos que *g(n)* para entradas grandes.

---

# ğŸ“š Semana 5: Notaciones Î© (Omega) y Î˜ (Theta)

## ğŸ” Â¿QuÃ© es la notaciÃ³n Î© (Omega)?

Describe la **cota inferior** de un algoritmo, es decir, el mejor caso posible.

Asegura que el algoritmo tomarÃ¡ al menos esa cantidad de recursos para entradas grandes.

### ğŸ§  Ejemplo:

Si un algoritmo tiene **Î©(n)**, en el mejor de los casos requiere al menos **n** pasos para completarse.

## ğŸ” Â¿QuÃ© es la notaciÃ³n Î˜ (Theta)?

Describe un lÃ­mite ajustado (superior e inferior).

El algoritmo siempre tarda un tiempo proporcional a **g(n)** (ni mÃ¡s, ni menos asintÃ³ticamente).

### ğŸ¯ InterpretaciÃ³n

- **Cota estricta:** El tiempo de ejecuciÃ³n estÃ¡ acotado por arriba y por abajo.
- **Rendimiento promedio:** Representa bien el caso medio o comportamiento tÃ­pico.

### Ejemplo:

Un algoritmo con **Î˜(n log n)** se comporta asÃ­ en la mayorÃ­a de los casos, no solo en el peor o mejor.

---

## ğŸ“Œ NotaciÃ³n asintÃ³tica condicional

### ğŸ”§ Â¿QuÃ© es?

MÃ©todo para describir cÃ³mo un algoritmo escala con el tamaÃ±o de la entrada.

Se aplica a tiempo y espacio.

### ğŸ§  Â¿Para quÃ© sirve?

- Comparar algoritmos: Determinar cuÃ¡l es mÃ¡s eficiente.
- Simplificar anÃ¡lisis: Ignorar detalles menores y centrarse en el crecimiento.
- Predecir comportamiento: Saber cÃ³mo reaccionarÃ¡ ante grandes volÃºmenes de datos.

---
# ğŸ“… SEMANA 6

## âš™ï¸ Estructuras de Control

Las estructuras de control permiten gestionar el flujo de ejecuciÃ³n en un programa, determinando el orden en que las instrucciones se ejecutan. Gracias a ellas, el cÃ³digo puede tomar decisiones, repetir acciones o simplemente seguir un flujo secuencial.

### ğŸ› ï¸ Tipos de estructuras

- **Secuenciales:** Las instrucciones se ejecutan una tras otra en el orden que estÃ¡n escritas.

- **Condicionales:** Permiten que el programa tome decisiones basadas en condiciones.

  - **Simples:** Ejecutan un bloque de cÃ³digo solo si una condiciÃ³n es verdadera.

  - **Dobles:** Si la condiciÃ³n es verdadera se ejecuta un bloque, si es falsa, otro diferente.

  - **MÃºltiples:** Evaluan varias condiciones para manejar casos complejos.

- **Iterativas:** RepeticiÃ³n de instrucciones mÃºltiples veces, Ãºtil cuando no se conoce de antemano cuÃ¡ntas repeticiones se requieren.

### ğŸ¯ Objetivos

- Organizar y controlar el flujo de un algoritmo para tomar decisiones y repetir acciones.

- Mejorar la legibilidad, modularidad y eficiencia del cÃ³digo.

- Facilitar la toma de decisiones con condicionales.

- Permitir repeticiones controladas mediante bucles.

---

# ğŸ“… SEMANA 7

## ğŸ” AnÃ¡lisis del Caso Medio

El anÃ¡lisis de caso medio mide el rendimiento esperado de un algoritmo considerando todas las posibles entradas y sus probabilidades. Es una medida mÃ¡s realista que el anÃ¡lisis del mejor o peor caso.

### ğŸ§­ Proceso

1. Definir la distribuciÃ³n probabilÃ­stica de las entradas.

2. Calcular el costo de ejecuciÃ³n para cada tipo de entrada.

3. Promediar los costos ponderados por sus probabilidades.

4. Considerar el tamaÃ±o de la entrada para el cÃ¡lculo.

### âš–ï¸ Importancia

- Brinda una visiÃ³n realista del rendimiento en uso tÃ­pico.

- Facilita la comparaciÃ³n entre algoritmos.

- Ayuda a identificar oportunidades de optimizaciÃ³n.

### ğŸ§ª Ejemplo

En una bÃºsqueda lineal, el elemento puede estar en cualquier posiciÃ³n con igual probabilidad. El anÃ¡lisis calcula el promedio de comparaciones necesarias para encontrarlo.

---

## âš¡ AnÃ¡lisis Amortizado

El anÃ¡lisis amortizado evalÃºa el costo promedio de una secuencia de operaciones, en lugar de enfocarse en el costo individual mÃ¡s alto. Esto es Ãºtil cuando operaciones costosas ocurren raramente.

### ğŸ§ª Ejemplo

En una lista dinÃ¡mica, insertar puede ser O(1) usualmente, pero ocasionalmente O(n) para redimensionar. El anÃ¡lisis amortizado muestra que el costo promedio por inserciÃ³n sigue siendo O(1).

### ğŸ› ï¸ MÃ©todos comunes

- MÃ©todo de agregaciÃ³n

- MÃ©todo contable

- MÃ©todo potencial

### ğŸ¯ Importancia

Proporciona una visiÃ³n mÃ¡s realista del rendimiento en escenarios reales.

---

## ğŸ”„ Recurrencias

Una recurrencia es una ecuaciÃ³n que define una funciÃ³n en tÃ©rminos de valores menores de sÃ­ misma. Son clave para analizar algoritmos recursivos y "divide y vencerÃ¡s".

### ğŸ¯ Importancia

Permiten calcular la complejidad de algoritmos que dividen problemas en subproblemas mÃ¡s pequeÃ±os.

### ğŸ§ª Ejemplo

Factorial: T(n) = T(n-1) + 1, con T(1) = 1.

### ğŸ§® SoluciÃ³n

Se puede resolver con mÃ©todos como expansiÃ³n, maestro o sustituciÃ³n para obtener la complejidad asintÃ³tica.

### ğŸ“ˆ Complejidad

Por ejemplo, resolver una recurrencia puede mostrar que el algoritmo es O(n), es decir, crece linealmente con el tamaÃ±o de la entrada.


# REFERENCIAS BIBLIOGRÃFICAS

- Algoritmos: quÃ© son y quÃ© tipos existen - Ferrovial. (2025, 13 febrero). Ferrovial. https://www.ferrovial.com/es/stem/algoritmos/
- AnÃ¡lisis de algoritmos | Algoritmos y Estructura de Datos. (s.Â f.). https://www.luchonet.com.ar/aed/?page_id=209
- Chaves, J. (2025, 6 enero). Complejidad computacional. Diccionario InformÃ¡tico | Soporte TÃ©cnico. https://jeffrychaves.com/diccionario/complejidad-computacional/
